<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <title>The Chain Reaction Builder</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <link rel="stylesheet" href="index.css">
</head>
<body>
<!-- Mode Selection Screen -->
<div id="mode-selection">
    <img src="assets/logo.png" alt="The Chain Reaction Builder Logo" style="width: 55vw; min-width: 320px;"/>
    <button data-mode="debug">Debug a Machine</button>
    <button data-mode="scenario">Play Scenario</button>
    <button data-mode="sandbox">Sandbox Mode</button>
</div>

<!-- Scenario Selection Screen -->
<div id="scenario-selection">
    <button class="back" id="scenario-back">Back</button>
    <h2>Choose a Scenario</h2>
    <button class="scenario-button" data-scenario="bucket">Bucket Challenge</button>
    <button class="scenario-button" data-scenario="reveal-gift">Reveal a Gift</button>
</div>

<!-- Builder Interface -->
<div id="builder-interface">
    <!-- Builder View -->
    <div id="builder-view">
        <div id="builder-controls">
            <div class="top-row">
                <button id="return-home">Return Home</button>
                <div>
                    <button id="save-config">Save Config</button>
                    <select id="config-list">
                        <option value="">--Select Config--</option>
                    </select>
                    <button id="load-config">Load Config</button>
                </div>
            </div>
            <div class="bottom-row">
                <button id="reset-builder">Reset</button>
                <button id="undo-builder">Undo</button>
                <button id="redo-builder">Redo</button>
                <button id="run-simulation">Run Simulation</button>
            </div>
        </div>
        <div id="builder-container">
            <!-- Toolbox Panel -->
            <div id="toolbox">
                <h3>Toolbox</h3>
                <div class="component" draggable="true" data-type="bucket">Bucket</div>
                <div class="component" draggable="true" data-type="domino">Domino</div>
                <div class="component" draggable="true" data-type="inclined-plane">Inclined Plane</div>
                <div class="component" draggable="true" data-type="lever">Lever</div>
                <div class="component" draggable="true" data-type="pendulum">Pendulum</div>
                <div class="component" draggable="true" data-type="pulley">Pulley</div>
                <div class="component" draggable="true" data-type="skateboard">Skateboard</div>
                <div class="component" draggable="true" data-type="staircase">Staircase</div>
            </div>
            <!-- Builder Canvas -->
            <div id="builder-canvas"></div>
            <!-- Feedback Panel -->
            <div id="feedback">
                <h3>Help</h3>
                <p>
                    Drag items from the toolbox onto the canvas to build your machine.<br>
                    Reposition items by dragging them.<br>
                    Right-click an item to modify its properties.<br>
                    Use the buttons above to save, load, reset, undo, and redo your work.<br>
                    When you're ready, click "Run Simulation" to see your design in action!
                </p>
            </div>
        </div>
    </div>
    <!-- Simulation View -->
    <div id="simulation-view">
        <div id="simulation-controls">
            <button id="return-builder">Return to Builder</button>
        </div>
        <div id="phaser-container"></div>
    </div>
</div>

<!-- Modal Prompt Function -->
<script>
    function showPrompt(message, takeTextInput = true, defaultValue = '') {
        return new Promise((resolve) => {
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            const modalBox = document.createElement('div');
            modalBox.className = 'modal-box';
            const messageElem = document.createElement('p');
            messageElem.innerText = message;
            let inputElem;
            if (takeTextInput) {
                inputElem = document.createElement('input');
                inputElem.type = 'text';
                inputElem.value = defaultValue;
            }
            const buttonsDiv = document.createElement('div');
            buttonsDiv.className = 'modal-buttons';
            const continueButton = document.createElement('button');
            continueButton.innerText = 'Continue';
            const cancelButton = document.createElement('button');
            cancelButton.innerText = 'Cancel';
            buttonsDiv.appendChild(continueButton);
            buttonsDiv.appendChild(cancelButton);
            modalBox.appendChild(messageElem);
            if (takeTextInput) {
                modalBox.appendChild(inputElem);
            }
            modalBox.appendChild(buttonsDiv);
            overlay.appendChild(modalBox);
            document.body.appendChild(overlay);
            if (takeTextInput) {
                inputElem.focus();
            }
            continueButton.addEventListener('click', () => {
                document.body.removeChild(overlay);
                if (takeTextInput) {
                    resolve(inputElem.value);
                } else {
                    resolve(true);
                }
            });
            cancelButton.addEventListener('click', () => {
                document.body.removeChild(overlay);
                resolve(false);
            });
            if (takeTextInput) {
                inputElem.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        continueButton.click();
                    }
                });
            }
        });
    }
</script>

<!-- Properties Dialog Function -->
<script>
    function showPropertiesDialog(title, fields) {
        return new Promise((resolve) => {
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            const modalBox = document.createElement('div');
            modalBox.className = 'modal-box';
            const titleElem = document.createElement('h3');
            titleElem.innerText = title;
            modalBox.appendChild(titleElem);
            const form = document.createElement('form');
            fields.forEach(field => {
                const label = document.createElement('label');
                label.innerText = field.label;
                const input = document.createElement('input');
                input.type = 'text';
                input.name = field.name;
                input.value = field.value;
                form.appendChild(label);
                form.appendChild(input);
            });
            modalBox.appendChild(form);
            const buttonsDiv = document.createElement('div');
            buttonsDiv.className = 'modal-buttons';
            const okButton = document.createElement('button');
            okButton.innerText = 'OK';
            const cancelButton = document.createElement('button');
            cancelButton.innerText = 'Cancel';
            buttonsDiv.appendChild(okButton);
            buttonsDiv.appendChild(cancelButton);
            modalBox.appendChild(buttonsDiv);
            overlay.appendChild(modalBox);
            document.body.appendChild(overlay);
            form.addEventListener('submit', (e) => {
                e.preventDefault();
                okButton.click();
            });
            okButton.addEventListener('click', () => {
                const data = {};
                const inputs = form.querySelectorAll('input');
                inputs.forEach(input => {
                    data[input.name] = input.value;
                });
                document.body.removeChild(overlay);
                resolve(data);
            });
            cancelButton.addEventListener('click', () => {
                document.body.removeChild(overlay);
                resolve(null);
            });
        });
    }
</script>

<!-- Main Application Script -->
<script>
    document.addEventListener('DOMContentLoaded', function () {
        console.log("DOM fully loaded and parsed.");
        const Phaser = require('phaser');

        /***** Global Variables for Undo/Redo *****/
        let builderHistory = [];
        let historyIndex = -1;
        const builderCanvas = document.getElementById('builder-canvas');

        /***** Global Variables *****/
        let canvasWidth;
        let canvasHeight;

        function saveState() {
            builderHistory = builderHistory.slice(0, historyIndex + 1);
            builderHistory.push(builderCanvas.innerHTML);
            historyIndex++;
        }

        saveState();

        /***** Screen Toggle *****/
        const modeSelection = document.getElementById('mode-selection');
        const scenarioSelection = document.getElementById('scenario-selection');
        const builderInterface = document.getElementById('builder-interface');
        const builderView = document.getElementById('builder-view');
        const simulationView = document.getElementById('simulation-view');
        const modeButtons = document.querySelectorAll('#mode-selection button');
        modeButtons.forEach(button => {
            button.addEventListener('click', () => {
                const mode = button.getAttribute('data-mode');
                if (mode === "scenario") {
                    modeSelection.style.display = 'none';
                    scenarioSelection.style.display = 'flex';
                } else {
                    modeSelection.style.display = 'none';
                    builderInterface.style.display = 'block';
                    builderView.style.display = 'block';
                    simulationView.style.display = 'none';
                    updateConfigList();
                }
            });
        });
        document.getElementById('return-home').addEventListener('click', () => {
            builderCanvas.innerHTML = '';
            builderHistory = [];
            historyIndex = -1;
            saveState();
            builderInterface.style.display = 'none';
            modeSelection.style.display = 'flex';
        });

        // Back button in scenario selection screen
        document.getElementById('scenario-back').addEventListener('click', () => {
            scenarioSelection.style.display = 'none';
            modeSelection.style.display = 'flex';
        });

        // Scenario button click handler
        const scenarioButtons = document.querySelectorAll('.scenario-button');
        scenarioButtons.forEach(button => {
            button.addEventListener('click', () => {
                const scenario = button.getAttribute('data-scenario');
                let scenarioText = "";
                if (scenario === "bucket") {
                    scenarioText = "Bucket Challenge: A marble will drop from the top left. Your goal is to guide it to the bucket at the bottom right.";
                } else if (scenario === "reveal-gift") {
                    scenarioText = "Reveal a Gift: A gift box is connected to a pulley. Your goal is to lift the box to reveal the gift!";
                }
                showPrompt(scenarioText, false, "").then((response) => {
                    if (response) {
                        scenarioSelection.style.display = 'none';
                        builderInterface.style.display = 'block';
                        builderView.style.display = 'block';
                        simulationView.style.display = 'none';
                        updateConfigList();
                    }
                });
            });
        });

        /***** Builder Controls *****/
        document.getElementById('reset-builder').addEventListener('click', () => {
            builderCanvas.innerHTML = '';
            saveState();
        });
        document.getElementById('undo-builder').addEventListener('click', () => {
            if (historyIndex > 0) {
                historyIndex--;
                builderCanvas.innerHTML = builderHistory[historyIndex];
            }
        });
        document.getElementById('redo-builder').addEventListener('click', () => {
            if (historyIndex < builderHistory.length - 1) {
                historyIndex++;
                builderCanvas.innerHTML = builderHistory[historyIndex];
            }
        });

        /***** Save/Load Configuration *****/
        document.getElementById('save-config').addEventListener('click', () => {
            showPrompt("Enter a name for this configuration:").then(configName => {
                if (!configName) return;
                const configData = [];
                const comps = builderCanvas.querySelectorAll('.dropped-component');
                comps.forEach(comp => {
                    configData.push({
                        ...Object.fromEntries(Object.entries(comp.style).filter(([_, value]) => Boolean(value))), // only include defined properties
                        ...Object.fromEntries(Object.entries(comp.dataset).filter(([_, value]) => Boolean(value)))
                    });
                });
                let savedConfigs = JSON.parse(localStorage.getItem('machineConfigs')) || {};
                savedConfigs[configName] = configData;
                localStorage.setItem('machineConfigs', JSON.stringify(savedConfigs));
                alert("Configuration saved!");
                updateConfigList();
            });
        });
        document.getElementById('load-config').addEventListener('click', () => {
            const select = document.getElementById('config-list');
            const configName = select.value;
            if (!configName) {
                alert("Please select a configuration to load.");
                return;
            }
            const savedConfigs = JSON.parse(localStorage.getItem('machineConfigs')) || {};
            const configData = savedConfigs[configName];
            if (!configData) {
                alert("Configuration not found.");
                return;
            }
            builderCanvas.innerHTML = '';
            configData.forEach(item => {
                createDroppedComponent(item.type, parseInt(item.centerX), parseInt(item.centerY), item);
            });
            saveState();
            alert("Configuration loaded!");
        });

        function updateConfigList() {
            const select = document.getElementById('config-list');
            select.innerHTML = '<option value="">--Select Config--</option>';
            const savedConfigs = JSON.parse(localStorage.getItem('machineConfigs')) || {};
            Object.keys(savedConfigs).forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                option.innerText = name;
                select.appendChild(option);
            });
        }

        /***** Basic Drag and Drop for Toolbox Components *****/
        const components = document.querySelectorAll('.component');
        components.forEach(component => {
            component.addEventListener('dragstart', (e) => {
                e.dataTransfer.setData('text/plain', component.getAttribute('data-type'));
            });
        });
        builderCanvas.addEventListener('dragover', (e) => {
            e.preventDefault();
        });
        builderCanvas.addEventListener('drop', (e) => {
            e.preventDefault();
            const componentType = e.dataTransfer.getData('text/plain');
            const rect = builderCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            createDroppedComponent(componentType, x, y, {left: e.offsetX, top: e.offsetY});
            saveState();
        });

        function createDroppedComponent(componentType, centerX, centerY, properties = {}) {
            const canvasRect = builderCanvas.getBoundingClientRect();
            canvasWidth = canvasRect.width;
            canvasHeight = canvasRect.height;

            const newComponent = document.createElement('div');
            newComponent.className = 'dropped-component ' + componentType;

            newComponent.innerText = 'Dropped Component';
            newComponent.style.left = `${parseInt(properties.left)}px`;
            newComponent.style.top = `${parseInt(properties.top)}px`;
            newComponent.dataset.type = componentType;
            newComponent.dataset.angle = properties.angle || '0';

            // Bucket
            if (componentType === 'bucket') {
                newComponent.innerText = 'Bucket';
                newComponent.style.width = properties.width || '50px';
                newComponent.style.height = properties.height || '30px';
                newComponent.style.backgroundColor = '#ffa';
            }

            // Domino
            if (componentType === 'domino') {
                newComponent.innerText = 'Domino';
                newComponent.style.width = properties.width || '20px';
                newComponent.style.height = properties.height || '60px';
                newComponent.style.backgroundColor = '#ccc';
                newComponent.dataset.tiltDomino = properties.tiltDomino || 'no';
            }

            // Inclined Plane
            if (componentType === 'inclined-plane') {
                newComponent.innerText = 'Inclined Plane';
                newComponent.style.width = properties.width || '150px';
                newComponent.style.height = properties.height || '30px';
                newComponent.dataset.angle = properties.angle || '0';
                newComponent.style.transform = `rotate(${newComponent.dataset.angle}deg)`;
                newComponent.dataset.friction = properties.friction || '0.05';
            }

            // Lever
            if (componentType === 'lever') {
                newComponent.innerText = 'Lever';
                newComponent.style.width = properties.width || '100px';
                newComponent.style.height = properties.height || '20px';
                newComponent.dataset.fulcrum = properties.fulcrum || 'center';
                newComponent.dataset.pivot = properties.pivot || '0.5';
            }

            // Pendulum
            if (componentType === 'pendulum') {
                newComponent.innerText = 'Pendulum';
                newComponent.style.width = '40px';
                newComponent.style.height = '40px';
                newComponent.style.borderRadius = '50%';
                newComponent.style.backgroundColor = '#cfc';
                newComponent.dataset.friction = properties.friction || '0.1';
                newComponent.dataset.radius = properties.radius || '25';
            }

            // Pulley
            if (componentType === 'pulley') {
                newComponent.innerText = 'Pulley';
                newComponent.style.width = '60px';
                newComponent.style.height = '60px';
                newComponent.dataset.friction = properties.friction || '0.1';
                newComponent.dataset.radius = properties.radius || '25';
                newComponent.dataset.bucketOnLeft = properties.bucketOnLeft || 'yes';
            }

            // Skateboard
            if (componentType === 'skateboard') {
                newComponent.innerText = 'Skateboard';
                newComponent.style.width = properties.width || '80px';
                newComponent.style.height = properties.height || '20px';
                newComponent.style.borderRadius = '10px';
                newComponent.style.backgroundColor = '#fcc';
            }

            // Staircase
            if (componentType === 'staircase') {
                newComponent.innerText = 'Staircase';
                newComponent.style.backgroundColor = '#ddd';
                newComponent.style.border = '2px solid #999';
                newComponent.style.boxSizing = 'border-box';

                // used purely for display on canvas
                newComponent.style.width = `${(properties.width ? parseInt(properties.width) : 120) * 1.5}px`;
                newComponent.style.height = `${(properties.height ? parseInt(properties.height) : 40) * 3}px`;

                // these dimensions will override the style when the translation to phaser occurs
                newComponent.dataset.width = properties.width || '120px';
                newComponent.dataset.height = properties.height || '20px';
            }

            newComponent.dataset.centerX = `${parseInt(newComponent.style.left) + parseInt(newComponent.style.width) / 2}`;
            newComponent.dataset.centerY = `${parseInt(newComponent.style.top) + parseInt(newComponent.style.height) / 2}`;

            newComponent.addEventListener('contextmenu', (event) => {
                event.preventDefault();

                const existingMenu = document.querySelector('.custom-context-menu');
                if (existingMenu) existingMenu.remove();

                const menu = document.createElement('div');
                menu.className = 'custom-context-menu';
                menu.style.position = 'absolute';
                menu.style.top = event.clientY + 'px';
                menu.style.left = event.clientX + 'px';
                menu.style.backgroundColor = '#fff';
                menu.style.border = '1px solid #ccc';
                menu.style.padding = '5px';
                menu.style.zIndex = '1000';

                // Edit Option.
                const editOption = document.createElement('div');
                editOption.innerText = 'Edit';
                editOption.style.cursor = 'pointer';
                editOption.style.marginBottom = '5px';
                editOption.addEventListener('click', () => {
                    if (newComponent.dataset.type === 'bucket') {
                        const fields = [
                            {name: 'width', label: 'Width:', value: newComponent.style.width},
                            {name: 'height', label: 'Height:', value: newComponent.style.height}
                        ];
                        showPropertiesDialog('Edit Bucket Properties', fields).then(data => {
                            if (data !== null) {
                                newComponent.style.width = data.width;
                                newComponent.style.height = data.height;
                            }
                        });
                    } else if (newComponent.dataset.type === 'domino') {
                        const fields = [
                            {name: 'width', label: 'Width:', value: newComponent.style.width},
                            {name: 'height', label: 'Height:', value: newComponent.style.height},
                            {name: 'tiltDomino', label: 'Tilt this domino? (yes or no):', value: newComponent.dataset.tiltDomino}
                        ];
                        showPropertiesDialog('Edit Domino Properties', fields).then(data => {
                            if (data !== null) {
                                newComponent.style.width = data.width;
                                newComponent.style.height = data.height;
                                newComponent.dataset.tiltDomino = data.tiltDomino;
                            }
                        });
                    } else if (newComponent.dataset.type === 'inclined-plane') {
                        const fields = [
                            {name: 'angle', label: 'Angle (degrees):', value: newComponent.dataset.angle},
                            {name: 'friction', label: 'Friction coefficient:', value: newComponent.dataset.friction},
                            {name: 'width', label: 'Width:', value: newComponent.style.width},
                            {name: 'height', label: 'Height:', value: newComponent.style.height},

                        ];
                        showPropertiesDialog('Edit Inclined Plane Properties', fields).then(data => {
                            if (data !== null) {
                                newComponent.dataset.angle = data.angle;
                                newComponent.dataset.friction = data.friction;
                                newComponent.style.width = data.width;
                                newComponent.style.height = data.height;
                                newComponent.style.transform = `rotate(${data.angle}deg)`;
                            }
                        });
                    } else if (newComponent.dataset.type === 'lever') {
                        const fields = [
                            {
                                name: 'fulcrum',
                                label: 'Fulcrum (left, center, right):',
                                value: newComponent.dataset.fulcrum
                            },
                            {name: 'width', label: 'Width:', value: newComponent.style.width},
                            {name: 'height', label: 'Height:', value: newComponent.style.height},

                        ];
                        showPropertiesDialog('Edit Lever Properties', fields).then(data => {
                            if (data !== null) {
                                newComponent.dataset.fulcrum = data.fulcrum;
                                newComponent.style.width = data.width;
                                newComponent.style.height = data.height;
                            }
                        });
                    } else if (newComponent.dataset.type === 'pendulum') {
                        const fields = [
                            {name: 'radius', label: 'Radius:', value: newComponent.dataset.radius},
                        ];
                        showPropertiesDialog('Edit Pendulum Properties', fields).then(data => {
                            if (data !== null) {
                                newComponent.dataset.radius = data.radius;
                            }
                        });
                    } else if (newComponent.dataset.type === 'pulley') {
                        const fields = [
                            {name: 'radius', label: 'Radius:', value: newComponent.dataset.radius},
                            {
                                name: 'bucketOnLeft',
                                label: 'Bucket on left? (yes or no):',
                                value: newComponent.dataset.bucketOnleft
                            }
                        ];
                        showPropertiesDialog('Edit Pulley Properties', fields).then(data => {
                            if (data !== null) {
                                newComponent.dataset.radius = data.radius;
                                newComponent.dataset.bucketOnLeft = data.bucketOnLeft;
                            }
                        });
                    } else if (newComponent.dataset.type === 'skateboard') {
                        const fields = [
                            {name: 'width', label: 'Width:', value: newComponent.style.width},
                            {name: 'height', label: 'Height:', value: newComponent.style.height}
                        ];
                        showPropertiesDialog('Edit Skateboard Properties', fields).then(data => {
                            if (data !== null) {
                                newComponent.style.width = data.width;
                                newComponent.style.height = data.height;
                            }
                        });
                    } else if (newComponent.dataset.type === 'staircase') {
                        const fields = [
                            {name: 'width', label: 'Step Width:', value: newComponent.dataset.width},
                            {name: 'height', label: 'Step Height:', value: newComponent.dataset.height}
                        ];
                        showPropertiesDialog('Edit Staircase Properties', fields).then(data => {
                            if (data !== null) {
                                // used purely for display on canvas
                                newComponent.style.width = `${(data.width ? parseInt(data.width) : 120) * 1.5}px`;
                                newComponent.style.height = `${(data.height ? parseInt(data.height) : 40) * 3}px`;

                                // these dimensions will override the style when the translation to phaser occurs
                                newComponent.dataset.width = data.width;
                                newComponent.dataset.height = data.height;
                            }
                        });
                    }
                    menu.remove();
                });

                // Delete Option.
                const deleteOption = document.createElement('div');
                deleteOption.innerText = 'Delete';
                deleteOption.style.cursor = 'pointer';
                deleteOption.addEventListener('click', () => {
                    newComponent.remove();
                    menu.remove();
                });

                menu.appendChild(editOption);
                menu.appendChild(deleteOption);
                document.body.appendChild(menu);

                // Remove the context menu if clicking anywhere else.
                document.addEventListener('click', function handler() {
                    menu.remove();
                    document.removeEventListener('click', handler);
                });
            });

            newComponent.addEventListener('mousedown', (event) => {
                if (event.button !== 0) return;
                const offsetX = event.clientX - newComponent.offsetLeft;
                const offsetY = event.clientY - newComponent.offsetTop;

                function mouseMoveHandler(e) {
                    newComponent.style.left = e.clientX - offsetX + 'px';
                    newComponent.style.top = e.clientY - offsetY + 'px';
                }

                function mouseUpHandler() {
                    document.removeEventListener('mousemove', mouseMoveHandler);
                    document.removeEventListener('mouseup', mouseUpHandler);
                    updateDroppedComponentPosition(newComponent);
                    saveState();
                }

                document.addEventListener('mousemove', mouseMoveHandler);
                document.addEventListener('mouseup', mouseUpHandler);
            });
            builderCanvas.appendChild(newComponent);
        }

        function updateDroppedComponentPosition(component) {
            // Get the current left and top from the inline style
            const left = parseInt(component.style.left) || 0;
            const top = parseInt(component.style.top) || 0;
            // Get computed width and height (if not set inline)
            const computedStyle = window.getComputedStyle(component);
            const width = parseInt(computedStyle.width) || 0;
            const height = parseInt(computedStyle.height) || 0;
            // Update the dataset with the center position
            component.dataset.centerX = left + width / 2;
            component.dataset.centerY = top + height / 2;
        }


        /***** Simulation Setup (using Matter.js) *****/
        let game;
        let simConfig;

        function createSimulation(configData) {
            simConfig = {
                type: Phaser.AUTO,
                parent: 'phaser-container',
                width: canvasWidth,
                height: canvasHeight,
                physics: {
                    default: 'matter',
                    matter: {
                        gravity: {y: 1},
                        debug: true
                    }
                },
                scene: {
                    init: function () {
                        this.windowWidth = canvasWidth;
                        this.windowHeight = canvasHeight;
                        this.configData = configData;
                        this.levers = [];
                        this.pulleys = [];
                    },
                    preload: preloadSim,
                    create: createSim,
                    update: updateSim
                }
            };
            game = new Phaser.Game(simConfig);
        }

        function preloadSim() {
            this.load.image('sky', 'https://labs.phaser.io/assets/skies/gradient15.png');
            this.load.image('pegboard', 'assets/pegboard.png');
        }

        function createSim() {
            this.matter.world.setBounds(0, 0, this.windowWidth, this.windowHeight);
            this.add.image(0, 0, 'pegboard').setOrigin(0, 0);

            // Create composite/compound bodies for each builder item:
            this.configData.forEach(item => {
                let centerX = parseInt(item.centerX);
                let centerY = parseInt(item.centerY);
                const width = parseInt(item.width);
                const height = parseInt(item.height);

                // -------------------------
                // Bucket
                if (item.type === 'bucket') {
                    // A simple dynamic bucket that could, for instance, collect marbles.
                    const bucket = this.matter.bodies.rectangle(centerX, centerY, width, height, {
                        restitution: 0,
                        friction: parseFloat(item.friction) || 0.1
                    });
                    bucket.label = 'bucket';
                    this.matter.world.add(bucket);
                }

                // -------------------------
                // Domino
                if (item.type === 'domino') {
                    const domino = this.matter.bodies.rectangle(centerX, centerY, width, height, {
                        restitution: 0,
                        friction: 1
                    });
                    this.matter.world.add(domino);

                    if(item.tiltDomino === 'yes') {
                        this.matter.body.rotate(domino, 0.3);
                    }
                }

                // -------------------------
                // Inclined Plane
                if (item.type === 'inclined-plane') {
                    let angleRad = Phaser.Math.DegToRad(parseFloat(item.angle) || 0);
                    let plane = this.matter.bodies.rectangle(centerX, centerY, width, height, {
                        isStatic: true,
                        friction: parseFloat(item.friction) || 0.05,
                        angle: angleRad
                    });
                    this.matter.world.add(plane);
                }

                // -------------------------
                // Lever
                if (item.type === 'lever') {
                    let pivotRatio;
                    switch (item.fulcrum) {
                        case 'left':
                            pivotRatio = 0.25;
                            break;
                        case 'right':
                            pivotRatio = 0.75;
                            break;
                        case 'center':
                        default:
                            pivotRatio = 0.5;
                    }
                    const leverThickness = height / 2;
                    let lever = this.matter.bodies.rectangle(centerX, centerY, width, leverThickness, {
                        restitution: 0,
                        friction: parseFloat(item.friction) || 0.1
                    });
                    let pivotX = centerX - 50 + pivotRatio * 100;
                    let pivotY = centerY + leverThickness;
                    let fulcrum = this.matter.bodies.polygon(pivotX, pivotY, 3, leverThickness / 2, {
                        isStatic: true,
                        angle: Phaser.Math.DegToRad(208)
                    });
                    let leverConstraint = this.matter.constraint.create({
                        bodyA: lever,
                        pointA: {x: -50 + pivotRatio * 100, y: 0},
                        pointB: { x: pivotX, y: pivotY - leverThickness },
                        stiffness: 1,
                        length: 0
                    });
                    let leverComposite = this.matter.composite.create();
                    this.matter.composite.add(leverComposite, lever);
                    this.matter.composite.add(leverComposite, fulcrum);
                    this.matter.composite.add(leverComposite, leverConstraint);
                    this.matter.world.add(leverComposite);
                    let minAngle = Phaser.Math.DegToRad(-30);
                    let maxAngle = Phaser.Math.DegToRad(30);
                    this.levers.push({body: lever, min: minAngle, max: maxAngle});
                }

                // -------------------------
                // Pendulum
                if (item.type === 'pendulum') {
                    // For a pendulum, we create a bob (circle) and attach it to a fixed pivot above.
                    const pivotPoint = {x: centerX, y: centerY - 100}; // pivot 100px above
                    const bob = this.matter.bodies.circle(centerX, centerY, parseInt(item.radius), {
                        restitution: 0.8,
                        friction: parseFloat(item.friction) || 0.1,
                    });
                    this.matter.world.add(bob);
                    const pendulumConstraint = this.matter.constraint.create({
                        pointA: pivotPoint,
                        bodyB: bob,
                        pointB: {x: 0, y: 0},
                        length: 100,
                        stiffness: 1
                    });
                    this.matter.world.add(pendulumConstraint);
                }

                // -------------------------
                // Pulley
                if (item.type === 'pulley') {
                    let radius = parseFloat(item.radius) || 30;
                    // Create the static pulley wheel.
                    const pulleyWheel = this.matter.bodies.circle(centerX, centerY, radius, {
                        isStatic: true
                    });
                    this.matter.world.add(pulleyWheel);

                    // Create an invisible blockage (a thin horizontal barrier)
                    // Positioned at the top of the pulley (i.e. at the pulley's y-coordinate)
                    // This will prevent the chain from "falling through" the pulley wheel
                    const blockage = this.matter.bodies.rectangle(centerX, centerY, radius * 2.2, 5, {
                        isStatic: true,
                        render: {visible: false}
                    });
                    this.matter.world.add(blockage);

                    // Set up the chain.
                    const chainLength = radius * 0.75;
                    const chainLinks = [];
                    const linkRadius = 5;
                    const beltRadius = radius + linkRadius;
                    for (let i = 0; i < chainLength; i++) {
                        const fraction = i / (chainLength - 1);
                        const angle = -Math.PI + fraction * Math.PI; // from -Ï€ to 0 (top half)
                        const x = pulleyWheel.position.x + beltRadius * Math.cos(angle);
                        const y = pulleyWheel.position.y + beltRadius * Math.sin(angle);
                        const link = this.matter.bodies.circle(x, y, linkRadius, {
                            friction: 0.1,
                            restitution: 0
                        });
                        this.matter.world.add(link);
                        chainLinks.push(link);
                    }
                    for (let i = 0; i < chainLinks.length - 1; i++) {
                        const linkConstraint = this.matter.constraint.create({
                            bodyA: chainLinks[i],
                            bodyB: chainLinks[i + 1],
                            length: linkRadius * 2 + 1,
                            stiffness: 1
                        });
                        this.matter.world.add(linkConstraint);
                    }

                    this.pulleys.push({pulleyWheel, chainLinks, radius, linkRadius, blockage});

                    const pulleyItemsY = centerY - radius - 1;
                    const rightItemX = centerX + radius + 10;
                    const leftItemX = centerX - radius - 10;

                    // Set left/right items (choose which side is bucket and which is hook).
                    let leftItem = item.bucketOnLeft === 'yes' ? 'bucket' : 'hook';
                    let rightItem = item.bucketOnLeft === 'yes' ? 'hook' : 'bucket';

                    const bucket = this.matter.bodies.rectangle(
                        leftItem === 'bucket' ? leftItemX : rightItemX,
                        pulleyItemsY,
                        50,
                        30,
                        {restitution: 0, friction: 0.1}
                    );
                    bucket.label = 'bucket';
                    this.matter.world.add(bucket);

                    const hook = this.matter.bodies.rectangle(
                        leftItem === 'hook' ? leftItemX : rightItemX,
                        pulleyItemsY,
                        30,
                        30,
                        {restitution: 0, friction: 0.1, density: bucket.density * 2.75}
                    );
                    hook.label = 'hook';
                    this.matter.world.add(hook);

                    // Create constraints to attach bucket and hook.
                    const leftItemConstraint = this.matter.constraint.create({
                        bodyA: chainLinks[chainLinks.length - 1],
                        bodyB: leftItem === 'bucket' ? bucket : hook,
                        pointA: {x: 0, y: linkRadius},
                        pointB: {x: 0, y: -15},
                        stiffness: 0.9,
                        length: 2
                    });
                    this.matter.world.add(leftItemConstraint);

                    const rightItemConstraint = this.matter.constraint.create({
                        bodyA: rightItem === 'bucket' ? bucket : hook,
                        bodyB: chainLinks[0],
                        pointA: {x: 0, y: -15},
                        pointB: {x: 0, y: linkRadius},
                        stiffness: 0.9,
                        length: 2
                    });
                    this.matter.world.add(rightItemConstraint);
                }

                // -------------------------
                // Skateboard
                if (item.type === 'skateboard') {
                    // Create a composite: a board with two wheels.
                    const board = this.matter.bodies.rectangle(centerX, centerY, width, height, {
                        restitution: 0,
                        friction: parseFloat(item.friction) || 0.2
                    });
                    const wheelRadius = height / 2;
                    const wheelOffsetX = height + 10;
                    // Position wheels slightly below the board.
                    const leftWheel = this.matter.bodies.circle(centerX - wheelOffsetX, centerY + height, wheelRadius, {
                        restitution: 0,
                        friction: parseFloat(item.friction) || 0.8
                    });
                    const rightWheel = this.matter.bodies.circle(centerX + wheelOffsetX, centerY + height, wheelRadius, {
                        restitution: 0,
                        friction: parseFloat(item.friction) || 0.8
                    });
                    this.matter.world.add(board);
                    this.matter.world.add(leftWheel);
                    this.matter.world.add(rightWheel);
                    // Attach wheels to the board.
                    const leftConstraint = this.matter.constraint.create({
                        bodyA: board,
                        pointA: {x: -wheelOffsetX, y: height},
                        bodyB: leftWheel,
                        pointB: {x: 0, y: 0},
                        stiffness: 1,
                        length: 0
                    });
                    const rightConstraint = this.matter.constraint.create({
                        bodyA: board,
                        pointA: {x: wheelOffsetX, y: height},
                        bodyB: rightWheel,
                        pointB: {x: 0, y: 0},
                        stiffness: 1,
                        length: 0
                    });
                    this.matter.world.add(leftConstraint);
                    this.matter.world.add(rightConstraint);
                }

                // -------------------------
                // Staircase
                if (item.type === 'staircase') {
                    // Create a simple staircase composed of three static steps.
                    const numberOfSteps = 3;
                    for (let i = 0; i < numberOfSteps; i++) {
                        // Position each step with a slight horizontal offset and vertical offset.
                        const stepX = centerX + i * (width / numberOfSteps);
                        const stepY = centerY + i * height;
                        const step = this.matter.bodies.rectangle(stepX, stepY, width, height, {
                            isStatic: true,
                            friction: 0.5
                        });
                        this.matter.world.add(step);
                    }
                }

                // -------------------------
                // Default: if no specific type, create a static box.
                if (!['bucket', 'domino', 'inclined-plane', 'lever', 'pendulum', 'pulley', 'skateboard', 'staircase'].includes(item.type)) {
                    let box = this.matter.bodies.rectangle(centerX, centerY, 80, 80, {isStatic: true});
                    this.matter.world.add(box);
                }
            });

            // On pointer down, drop a dynamic marble.
            this.input.on('pointerdown', function (pointer) {
                let marble = this.matter.bodies.circle(pointer.x, pointer.y, 15, {
                    restitution: 0.8,
                    friction: 0.005
                });
                marble.label = 'marble';
                this.matter.world.add(marble);
            }, this);

            // Collision event: when a marble hits the bucket, increase the bucket's mass and remove the marble.
            this.matter.world.on('collisionstart', function (event) {
                event.pairs.forEach(pair => {
                    const {bodyA, bodyB} = pair;
                    if ((bodyA.label === 'bucket' && bodyB.label === 'marble') ||
                        (bodyB.label === 'bucket' && bodyA.label === 'marble')) {
                        const bucket = bodyA.label === 'bucket' ? bodyA : bodyB;
                        const marble = bodyA.label === 'marble' ? bodyA : bodyB;
                        // Increase the bucket's mass (up to a maximum, e.g. 2.5).
                        this.matter.body.setMass(bucket, Math.min(bucket.mass + marble.mass, 2.5));
                        // Remove the marble.
                        this.matter.world.remove(marble);
                    }
                });
            }, this);
        }

        function updateSim() {
            // Clamp lever angles.
            if (this.levers) {
                this.levers.forEach(({body, min, max}) => {
                    if (body.angle < min) {
                        this.matter.body.setAngle(body, min);
                        this.matter.body.setAngularVelocity(body, 0);
                    }
                    if (body.angle > max) {
                        this.matter.body.setAngle(body, max);
                        this.matter.body.setAngularVelocity(body, 0);
                    }
                });
            }
            // Enforce blockage: ensure that key chain links on both sides do not rise above the pulley wheel.
            if (this.pulleys) {
                this.pulleys.forEach(({pulleyWheel, chainLinks}) => {
                    // Assume that on the hook side, chainLinks[3] should not rise above pulleyWheel.y.
                    if (chainLinks.length > 3) {
                        let hookKey = chainLinks[3];
                        if (hookKey.position.y < pulleyWheel.position.y) {
                            this.matter.body.setPosition(hookKey, {x: hookKey.position.x, y: pulleyWheel.position.y});
                            this.matter.body.setVelocity(hookKey, {x: 0, y: 0});
                        }
                    }
                    // On the bucket side, chainLinks[chainLinks.length - 4] should not rise above pulleyWheel.y.
                    if (chainLinks.length >= 4) {
                        let bucketKey = chainLinks[chainLinks.length - 4];
                        if (bucketKey.position.y < pulleyWheel.position.y) {
                            this.matter.body.setPosition(bucketKey, {
                                x: bucketKey.position.x,
                                y: pulleyWheel.position.y
                            });
                            this.matter.body.setVelocity(bucketKey, {x: 0, y: 0});
                        }
                    }
                });
            }
        }

        /***** Transition to Simulation Mode *****/
        document.getElementById('run-simulation').addEventListener('click', () => {
            builderView.style.display = 'none';
            simulationView.style.display = 'block';
            const configData = [];
            const comps = builderCanvas.querySelectorAll('.dropped-component');
            comps.forEach(comp => {
                configData.push({
                    // type,
                    // x,
                    // y,
                    ...Object.fromEntries(Object.entries(comp.style).filter(([_, value]) => Boolean(value))), // only include defined properties
                    ...Object.fromEntries(Object.entries(comp.dataset).filter(([_, value]) => Boolean(value)))
                });
            });

            createSimulation(configData);
        });

        /***** Simulation Controls *****/
        document.getElementById('return-builder').addEventListener('click', () => {
            if (game) {
                game.destroy(true);
                game = null;
            }
            simulationView.style.display = 'none';
            builderView.style.display = 'block';
        });
    });
</script>
</body>
</html>
